# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

##   Generated via the command line invocation:
##	 swig -c++ -r -o sequential_analysis_wrap.cpp sequential_analysis.i


#                         srun.swg                            #
#
# This is the basic code that is needed at run time within R to
# provide and define the relevant classes.  It is included
# automatically in the generated code by copying the contents of
# srun.swg into the newly created binding code.


# This could be provided as a separate run-time library but this
# approach allows the code to to be included directly into the
# generated bindings and so removes the need to have and install an
# additional library.  We may however end up with multiple copies of
# this and some confusion at run-time as to which class to use. This
# is an issue when we use NAMESPACES as we may need to export certain
# classes.

######################################################################

if(length(getClassDef("RSWIGStruct")) == 0) 
  setClass("RSWIGStruct", representation("VIRTUAL"))



if(length(getClassDef("ExternalReference")) == 0) 
# Should be virtual but this means it loses its slots currently
#representation("VIRTUAL")
  setClass("ExternalReference", representation( ref = "externalptr"))



if(length(getClassDef("NativeRoutinePointer")) == 0) 
  setClass("NativeRoutinePointer", 
              representation(parameterTypes = "character",
                             returnType = "character",
                             "VIRTUAL"), 
              contains = "ExternalReference")

if(length(getClassDef("CRoutinePointer")) == 0) 
  setClass("CRoutinePointer", contains = "NativeRoutinePointer")


if(length(getClassDef("EnumerationValue")) == 0) 
  setClass("EnumerationValue", contains = "integer")


if(!isGeneric("copyToR")) 
 setGeneric("copyToR",
            function(value, obj = new(gsub("Ref$", "", class(value)))) 
               standardGeneric("copyToR"
           ))

setGeneric("delete", function(obj) standardGeneric("delete"))


SWIG_createNewRef = 
function(className, ..., append = TRUE)
{
  f = get(paste("new", className, sep = "_"), mode = "function")

  f(...)
}

if(!isGeneric("copyToC")) 
 setGeneric("copyToC", 
             function(value, obj = SWIG_createNewRef(class(value)))
              standardGeneric("copyToC"
            ))


# 
defineEnumeration =
function(name, .values, where = topenv(parent.frame()), suffix = "Value")
{
   # Mirror the class definitions via the E analogous to .__C__
  defName = paste(".__E__", name, sep = "")
  assign(defName,  .values,  envir = where)

  if(nchar(suffix))
    name = paste(name, suffix, sep = "")

  setClass(name, contains = "EnumerationValue", where = where)
}

enumToInteger <- function(name,type)
{
   if (is.character(name)) {
   ans <- as.integer(get(paste(".__E__", type, sep = ""))[name])
   if (is.na(ans)) {warning("enum not found ", name, " ", type)}
   ans
   } 
}

enumFromInteger =
function(i,type)
{
  itemlist <- get(paste(".__E__", type, sep=""))
  names(itemlist)[match(i, itemlist)]
}

coerceIfNotSubclass =
function(obj, type) 
{
    if(!is(obj, type)) {as(obj, type)} else obj
}


setClass("SWIGArray", representation(dims = "integer"), contains = "ExternalReference")

setMethod("length", "SWIGArray", function(x) x@dims[1])


defineEnumeration("SCopyReferences",
                   .values = c( "FALSE" = 0, "TRUE" = 1, "DEEP" = 2))

assert = 
function(condition, message = "")
{
  if(!condition)
    stop(message)

  TRUE
}


if(FALSE) {
print.SWIGFunction =
function(x, ...)
 {
 }
}


#######################################################################

R_SWIG_getCallbackFunctionStack =
function()
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_debug_getCallbackFunctionData")
}

R_SWIG_addCallbackFunctionStack =
function(fun, userData = NULL)
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_R_pushCallbackFunctionData", fun, userData)
}


#######################################################################



setClass('C++Reference', contains = 'ExternalReference')
setClass('_p_std__vectorT_int_std__allocatorT_int_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_double_std__allocatorT_double_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', contains = 'C++Reference')
setClass('_p_ConnectivityMatrix', contains = 'C++Reference')



setMethod('[', "ExternalReference",
function(x,i,j, ..., drop=TRUE) 
if (!is.null(x$"__getitem__")) 
sapply(i, function(n) x$"__getitem__"(i=as.integer(n-1))))

setMethod('[<-' , "ExternalReference",
function(x,i,j, ..., value) 
if (!is.null(x$"__setitem__")) {
sapply(1:length(i), function(n) 
x$"__setitem__"(i=as.integer(i[n]-1), x=value[n]))
x
})

setAs('ExternalReference', 'character',
function(from) {if (!is.null(from$"__str__")) from$"__str__"()})

suppressWarnings(setMethod('print', 'ExternalReference',
function(x) {print(as(x, "character"))}))

# Start of IntVector___nonzero__

`IntVector___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_IntVector___nonzero__', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntVector___nonzero__`, 'returnType') = 'logical'
attr(`IntVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector___nonzero__`) = c("SWIGFunction", class('IntVector___nonzero__'))

# Start of IntVector___len__

`IntVector___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_IntVector___len__', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntVector___len__`, 'returnType') = 'integer'
attr(`IntVector___len__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector___len__`) = c("SWIGFunction", class('IntVector___len__'))

# Start of IntVector_pop

`IntVector_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_IntVector_pop', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntVector_pop`, 'returnType') = 'integer'
attr(`IntVector_pop`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector_pop`) = c("SWIGFunction", class('IntVector_pop'))

# Start of IntVector___getslice__

`IntVector___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_IntVector___getslice__', self, i, j, PACKAGE='sequential_analysis_wrap');
  ans <- new("_p_std__vectorT_int_std__allocatorT_int_t_t", ref=ans) ;
  
  ans
  
}

attr(`IntVector___getslice__`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`IntVector___getslice__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`IntVector___getslice__`) = c("SWIGFunction", class('IntVector___getslice__'))

# Start of IntVector___setslice__

`IntVector___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.integer(v);
  ;.Call('R_swig_IntVector___setslice__', self, i, j, v, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntVector___setslice__`, 'returnType') = 'void'
attr(`IntVector___setslice__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector___setslice__`) = c("SWIGFunction", class('IntVector___setslice__'))

# Start of IntVector___delslice__

`IntVector___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_IntVector___delslice__', self, i, j, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntVector___delslice__`, 'returnType') = 'void'
attr(`IntVector___delslice__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`IntVector___delslice__`) = c("SWIGFunction", class('IntVector___delslice__'))

# Start of IntVector___delitem__

`IntVector___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_IntVector___delitem__', self, i, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntVector___delitem__`, 'returnType') = 'void'
attr(`IntVector___delitem__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`IntVector___delitem__`) = c("SWIGFunction", class('IntVector___delitem__'))

# Start of IntVector___getitem__

`IntVector___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_IntVector___getitem__', self, i, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntVector___getitem__`, 'returnType') = 'integer'
attr(`IntVector___getitem__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`IntVector___getitem__`) = c("SWIGFunction", class('IntVector___getitem__'))

# Start of IntVector___setitem__

`IntVector___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_IntVector___setitem__', self, i, x, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntVector___setitem__`, 'returnType') = 'void'
attr(`IntVector___setitem__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`IntVector___setitem__`) = c("SWIGFunction", class('IntVector___setitem__'))

# Start of IntVector_append

`IntVector_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as.integer(x);
  ;.Call('R_swig_IntVector_append', self, x, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntVector_append`, 'returnType') = 'void'
attr(`IntVector_append`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`IntVector_append`) = c("SWIGFunction", class('IntVector_append'))

# Start of new_IntVector

`IntVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_IntVector__SWIG_0', PACKAGE='sequential_analysis_wrap');
  ans <- new("_p_std__vectorT_int_std__allocatorT_int_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_IntVector)
  ans
  
}

attr(`IntVector__SWIG_0`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
class(`IntVector__SWIG_0`) = c("SWIGFunction", class('IntVector__SWIG_0'))

# Start of new_IntVector

`IntVector__SWIG_1` = function(s_arg1)
{
  s_arg1 = as.integer(s_arg1);
  ;ans = .Call('R_swig_new_IntVector__SWIG_1', s_arg1, PACKAGE='sequential_analysis_wrap');
  ans <- new("_p_std__vectorT_int_std__allocatorT_int_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_IntVector)
  ans
  
}

attr(`IntVector__SWIG_1`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`IntVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector__SWIG_1`) = c("SWIGFunction", class('IntVector__SWIG_1'))

# Start of IntVector_empty

`IntVector_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_IntVector_empty', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntVector_empty`, 'returnType') = 'logical'
attr(`IntVector_empty`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector_empty`) = c("SWIGFunction", class('IntVector_empty'))

# Start of IntVector_size

`IntVector_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_IntVector_size', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntVector_size`, 'returnType') = 'integer'
attr(`IntVector_size`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector_size`) = c("SWIGFunction", class('IntVector_size'))

# Start of IntVector_clear

`IntVector_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_IntVector_clear', self, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntVector_clear`, 'returnType') = 'void'
attr(`IntVector_clear`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector_clear`) = c("SWIGFunction", class('IntVector_clear'))

# Start of IntVector_swap

`IntVector_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_IntVector_swap', self, v, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntVector_swap`, 'returnType') = 'void'
attr(`IntVector_swap`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector_swap`) = c("SWIGFunction", class('IntVector_swap'))

# Start of IntVector_get_allocator

`IntVector_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_IntVector_get_allocator', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  ans <- new("_p_std__allocatorT_int_t", ref=ans);
  
  ans
  
}

attr(`IntVector_get_allocator`, 'returnType') = '_p_std__allocatorT_int_t'
attr(`IntVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector_get_allocator`) = c("SWIGFunction", class('IntVector_get_allocator'))

# Start of new_IntVector

`IntVector__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_IntVector__SWIG_2', size, PACKAGE='sequential_analysis_wrap');
  ans <- new("_p_std__vectorT_int_std__allocatorT_int_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_IntVector)
  ans
  
}

attr(`IntVector__SWIG_2`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`IntVector__SWIG_2`, "inputTypes") = c('integer')
class(`IntVector__SWIG_2`) = c("SWIGFunction", class('IntVector__SWIG_2'))

# Start of IntVector_pop_back

`IntVector_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_IntVector_pop_back', self, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntVector_pop_back`, 'returnType') = 'void'
attr(`IntVector_pop_back`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector_pop_back`) = c("SWIGFunction", class('IntVector_pop_back'))

# Start of IntVector_resize

`IntVector_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_IntVector_resize__SWIG_0', self, new_size, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`IntVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`IntVector_resize__SWIG_0`) = c("SWIGFunction", class('IntVector_resize__SWIG_0'))

# Start of new_IntVector

`IntVector__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as.integer(value);
  ;ans = .Call('R_swig_new_IntVector__SWIG_3', size, value, PACKAGE='sequential_analysis_wrap');
  ans <- new("_p_std__vectorT_int_std__allocatorT_int_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_IntVector)
  ans
  
}

attr(`IntVector__SWIG_3`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`IntVector__SWIG_3`, "inputTypes") = c('integer', 'integer')
class(`IntVector__SWIG_3`) = c("SWIGFunction", class('IntVector__SWIG_3'))

`IntVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- IntVector__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- IntVector__SWIG_2; 
    }
    else if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) )) {
      f <- IntVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- IntVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for IntVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of IntVector_push_back

`IntVector_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as.integer(x);
  ;.Call('R_swig_IntVector_push_back', self, x, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntVector_push_back`, 'returnType') = 'void'
attr(`IntVector_push_back`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`IntVector_push_back`) = c("SWIGFunction", class('IntVector_push_back'))

# Start of IntVector_front

`IntVector_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_IntVector_front', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntVector_front`, 'returnType') = 'integer'
attr(`IntVector_front`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector_front`) = c("SWIGFunction", class('IntVector_front'))

# Start of IntVector_back

`IntVector_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_IntVector_back', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntVector_back`, 'returnType') = 'integer'
attr(`IntVector_back`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector_back`) = c("SWIGFunction", class('IntVector_back'))

# Start of IntVector_assign

`IntVector_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_IntVector_assign', self, n, x, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntVector_assign`, 'returnType') = 'void'
attr(`IntVector_assign`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`IntVector_assign`) = c("SWIGFunction", class('IntVector_assign'))

# Start of IntVector_resize

`IntVector_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_IntVector_resize__SWIG_1', self, new_size, x, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`IntVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`IntVector_resize__SWIG_1`) = c("SWIGFunction", class('IntVector_resize__SWIG_1'))

`IntVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_int_std__allocatorT_int_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- IntVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_int_std__allocatorT_int_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 )) {
      f <- IntVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for IntVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of IntVector_reserve

`IntVector_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_IntVector_reserve', self, n, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntVector_reserve`, 'returnType') = 'void'
attr(`IntVector_reserve`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`IntVector_reserve`) = c("SWIGFunction", class('IntVector_reserve'))

# Start of IntVector_capacity

`IntVector_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_IntVector_capacity', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntVector_capacity`, 'returnType') = 'integer'
attr(`IntVector_capacity`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntVector_capacity`) = c("SWIGFunction", class('IntVector_capacity'))

# Start of delete_IntVector

`delete_IntVector` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_IntVector', self, PACKAGE='sequential_analysis_wrap');
  
}

attr(`delete_IntVector`, 'returnType') = 'void'
attr(`delete_IntVector`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`delete_IntVector`) = c("SWIGFunction", class('delete_IntVector'))

# Start of accessor method for std::vector<(int)>
setMethod('$', '_p_std__vectorT_int_std__allocatorT_int_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = IntVector___nonzero__, '__len__' = IntVector___len__, 'pop' = IntVector_pop, '__getslice__' = IntVector___getslice__, '__setslice__' = IntVector___setslice__, '__delslice__' = IntVector___delslice__, '__delitem__' = IntVector___delitem__, '__getitem__' = IntVector___getitem__, '__setitem__' = IntVector___setitem__, 'append' = IntVector_append, 'empty' = IntVector_empty, 'size' = IntVector_size, 'clear' = IntVector_clear, 'swap' = IntVector_swap, 'get_allocator' = IntVector_get_allocator, 'pop_back' = IntVector_pop_back, 'resize' = IntVector_resize, 'push_back' = IntVector_push_back, 'front' = IntVector_front, 'back' = IntVector_back, 'assign' = IntVector_assign, 'reserve' = IntVector_reserve, 'capacity' = IntVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(int)>
setMethod('delete', '_p_std__vectorT_int_std__allocatorT_int_t_t', function(obj) {delete_std__vectorT_int_std__allocatorT_int_t_t(obj)})
# Start of IntMatrix___nonzero__

`IntMatrix___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_IntMatrix___nonzero__', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntMatrix___nonzero__`, 'returnType') = 'logical'
attr(`IntMatrix___nonzero__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t')
class(`IntMatrix___nonzero__`) = c("SWIGFunction", class('IntMatrix___nonzero__'))

# Start of IntMatrix___len__

`IntMatrix___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_IntMatrix___len__', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntMatrix___len__`, 'returnType') = 'integer'
attr(`IntMatrix___len__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t')
class(`IntMatrix___len__`) = c("SWIGFunction", class('IntMatrix___len__'))

# Start of IntMatrix_pop

`IntMatrix_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_IntMatrix_pop', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  ans <- new("_p_std__vectorT_int_std__allocatorT_int_t_t", ref=ans);
  
  ans
  
}

attr(`IntMatrix_pop`, 'returnType') = 'integer'
attr(`IntMatrix_pop`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t')
class(`IntMatrix_pop`) = c("SWIGFunction", class('IntMatrix_pop'))

# Start of IntMatrix___getslice__

`IntMatrix___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_IntMatrix___getslice__', self, i, j, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntMatrix___getslice__`, 'returnType') = '_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t'
attr(`IntMatrix___getslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', 'integer', 'integer')
class(`IntMatrix___getslice__`) = c("SWIGFunction", class('IntMatrix___getslice__'))

# Start of IntMatrix___setslice__

`IntMatrix___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = lapply(v, as.integer);
  ;.Call('R_swig_IntMatrix___setslice__', self, i, j, v, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntMatrix___setslice__`, 'returnType') = 'void'
attr(`IntMatrix___setslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', 'integer', 'integer', '_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t')
class(`IntMatrix___setslice__`) = c("SWIGFunction", class('IntMatrix___setslice__'))

# Start of IntMatrix___delslice__

`IntMatrix___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_IntMatrix___delslice__', self, i, j, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntMatrix___delslice__`, 'returnType') = 'void'
attr(`IntMatrix___delslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', 'integer', 'integer')
class(`IntMatrix___delslice__`) = c("SWIGFunction", class('IntMatrix___delslice__'))

# Start of IntMatrix___delitem__

`IntMatrix___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_IntMatrix___delitem__', self, i, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntMatrix___delitem__`, 'returnType') = 'void'
attr(`IntMatrix___delitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', 'integer')
class(`IntMatrix___delitem__`) = c("SWIGFunction", class('IntMatrix___delitem__'))

# Start of IntMatrix___getitem__

`IntMatrix___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_IntMatrix___getitem__', self, i, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  ans <- new("_p_std__vectorT_int_std__allocatorT_int_t_t", ref=ans) ;
  
  ans
  
}

attr(`IntMatrix___getitem__`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`IntMatrix___getitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', 'integer')
class(`IntMatrix___getitem__`) = c("SWIGFunction", class('IntMatrix___getitem__'))

# Start of IntMatrix___setitem__

`IntMatrix___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_IntMatrix___setitem__', self, i, x, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntMatrix___setitem__`, 'returnType') = 'void'
attr(`IntMatrix___setitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntMatrix___setitem__`) = c("SWIGFunction", class('IntMatrix___setitem__'))

# Start of IntMatrix_append

`IntMatrix_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as.integer(x);
  ;.Call('R_swig_IntMatrix_append', self, x, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntMatrix_append`, 'returnType') = 'void'
attr(`IntMatrix_append`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntMatrix_append`) = c("SWIGFunction", class('IntMatrix_append'))

# Start of new_IntMatrix

`IntMatrix__SWIG_0` = function()
{
  ;.Call('R_swig_new_IntMatrix__SWIG_0', PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntMatrix__SWIG_0`, 'returnType') = '_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t'
class(`IntMatrix__SWIG_0`) = c("SWIGFunction", class('IntMatrix__SWIG_0'))

# Start of new_IntMatrix

`IntMatrix__SWIG_1` = function(s_arg1)
{
  s_arg1 = lapply(s_arg1, as.integer);
  ;.Call('R_swig_new_IntMatrix__SWIG_1', s_arg1, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntMatrix__SWIG_1`, 'returnType') = '_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t'
attr(`IntMatrix__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t')
class(`IntMatrix__SWIG_1`) = c("SWIGFunction", class('IntMatrix__SWIG_1'))

# Start of IntMatrix_empty

`IntMatrix_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_IntMatrix_empty', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntMatrix_empty`, 'returnType') = 'logical'
attr(`IntMatrix_empty`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t')
class(`IntMatrix_empty`) = c("SWIGFunction", class('IntMatrix_empty'))

# Start of IntMatrix_size

`IntMatrix_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_IntMatrix_size', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntMatrix_size`, 'returnType') = 'integer'
attr(`IntMatrix_size`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t')
class(`IntMatrix_size`) = c("SWIGFunction", class('IntMatrix_size'))

# Start of IntMatrix_clear

`IntMatrix_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_IntMatrix_clear', self, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntMatrix_clear`, 'returnType') = 'void'
attr(`IntMatrix_clear`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t')
class(`IntMatrix_clear`) = c("SWIGFunction", class('IntMatrix_clear'))

# Start of IntMatrix_swap

`IntMatrix_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_IntMatrix_swap', self, v, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntMatrix_swap`, 'returnType') = 'void'
attr(`IntMatrix_swap`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', '_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t')
class(`IntMatrix_swap`) = c("SWIGFunction", class('IntMatrix_swap'))

# Start of IntMatrix_get_allocator

`IntMatrix_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_IntMatrix_get_allocator', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  ans <- new("_p_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t", ref=ans);
  
  ans
  
}

attr(`IntMatrix_get_allocator`, 'returnType') = '_p_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t'
attr(`IntMatrix_get_allocator`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t')
class(`IntMatrix_get_allocator`) = c("SWIGFunction", class('IntMatrix_get_allocator'))

# Start of new_IntMatrix

`IntMatrix__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_IntMatrix__SWIG_2', size, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntMatrix__SWIG_2`, 'returnType') = '_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t'
attr(`IntMatrix__SWIG_2`, "inputTypes") = c('integer')
class(`IntMatrix__SWIG_2`) = c("SWIGFunction", class('IntMatrix__SWIG_2'))

# Start of IntMatrix_pop_back

`IntMatrix_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_IntMatrix_pop_back', self, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntMatrix_pop_back`, 'returnType') = 'void'
attr(`IntMatrix_pop_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t')
class(`IntMatrix_pop_back`) = c("SWIGFunction", class('IntMatrix_pop_back'))

# Start of IntMatrix_resize

`IntMatrix_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_IntMatrix_resize__SWIG_0', self, new_size, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntMatrix_resize__SWIG_0`, 'returnType') = 'void'
attr(`IntMatrix_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', 'integer')
class(`IntMatrix_resize__SWIG_0`) = c("SWIGFunction", class('IntMatrix_resize__SWIG_0'))

# Start of new_IntMatrix

`IntMatrix__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as.integer(value);
  ;.Call('R_swig_new_IntMatrix__SWIG_3', size, value, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntMatrix__SWIG_3`, 'returnType') = '_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t'
attr(`IntMatrix__SWIG_3`, "inputTypes") = c('integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntMatrix__SWIG_3`) = c("SWIGFunction", class('IntMatrix__SWIG_3'))

`IntMatrix` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- IntMatrix__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- IntMatrix__SWIG_2; 
    }
    else if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) )) {
      f <- IntMatrix__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.integer(argv[[2]]) || is.numeric(argv[[2]]) )) {
      f <- IntMatrix__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for IntMatrix with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of IntMatrix_push_back

`IntMatrix_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as.integer(x);
  ;.Call('R_swig_IntMatrix_push_back', self, x, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntMatrix_push_back`, 'returnType') = 'void'
attr(`IntMatrix_push_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntMatrix_push_back`) = c("SWIGFunction", class('IntMatrix_push_back'))

# Start of IntMatrix_front

`IntMatrix_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_IntMatrix_front', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  ans <- new("_p_std__vectorT_int_std__allocatorT_int_t_t", ref=ans) ;
  
  ans
  
}

attr(`IntMatrix_front`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`IntMatrix_front`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t')
class(`IntMatrix_front`) = c("SWIGFunction", class('IntMatrix_front'))

# Start of IntMatrix_back

`IntMatrix_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_IntMatrix_back', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  ans <- new("_p_std__vectorT_int_std__allocatorT_int_t_t", ref=ans) ;
  
  ans
  
}

attr(`IntMatrix_back`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`IntMatrix_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t')
class(`IntMatrix_back`) = c("SWIGFunction", class('IntMatrix_back'))

# Start of IntMatrix_assign

`IntMatrix_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_IntMatrix_assign', self, n, x, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntMatrix_assign`, 'returnType') = 'void'
attr(`IntMatrix_assign`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntMatrix_assign`) = c("SWIGFunction", class('IntMatrix_assign'))

# Start of IntMatrix_resize

`IntMatrix_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_IntMatrix_resize__SWIG_1', self, new_size, x, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntMatrix_resize__SWIG_1`, 'returnType') = 'void'
attr(`IntMatrix_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`IntMatrix_resize__SWIG_1`) = c("SWIGFunction", class('IntMatrix_resize__SWIG_1'))

`IntMatrix_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- IntMatrix_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.integer(argv[[3]]) || is.numeric(argv[[3]]) )) {
      f <- IntMatrix_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for IntMatrix_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of IntMatrix_reserve

`IntMatrix_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_IntMatrix_reserve', self, n, PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntMatrix_reserve`, 'returnType') = 'void'
attr(`IntMatrix_reserve`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', 'integer')
class(`IntMatrix_reserve`) = c("SWIGFunction", class('IntMatrix_reserve'))

# Start of IntMatrix_capacity

`IntMatrix_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_IntMatrix_capacity', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`IntMatrix_capacity`, 'returnType') = 'integer'
attr(`IntMatrix_capacity`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t')
class(`IntMatrix_capacity`) = c("SWIGFunction", class('IntMatrix_capacity'))

# Start of delete_IntMatrix

`delete_IntMatrix` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_IntMatrix', self, PACKAGE='sequential_analysis_wrap');
  
}

attr(`delete_IntMatrix`, 'returnType') = 'void'
attr(`delete_IntMatrix`, "inputTypes") = c('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t')
class(`delete_IntMatrix`) = c("SWIGFunction", class('delete_IntMatrix'))

# Start of accessor method for std::vector<(std::vector<(int)>)>
setMethod('$', '_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = IntMatrix___nonzero__, '__len__' = IntMatrix___len__, 'pop' = IntMatrix_pop, '__getslice__' = IntMatrix___getslice__, '__setslice__' = IntMatrix___setslice__, '__delslice__' = IntMatrix___delslice__, '__delitem__' = IntMatrix___delitem__, '__getitem__' = IntMatrix___getitem__, '__setitem__' = IntMatrix___setitem__, 'append' = IntMatrix_append, 'empty' = IntMatrix_empty, 'size' = IntMatrix_size, 'clear' = IntMatrix_clear, 'swap' = IntMatrix_swap, 'get_allocator' = IntMatrix_get_allocator, 'pop_back' = IntMatrix_pop_back, 'resize' = IntMatrix_resize, 'push_back' = IntMatrix_push_back, 'front' = IntMatrix_front, 'back' = IntMatrix_back, 'assign' = IntMatrix_assign, 'reserve' = IntMatrix_reserve, 'capacity' = IntMatrix_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::vector<(int)>)>
setMethod('delete', '_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', function(obj) {delete_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t(obj)})
# Start of DoubleVector___nonzero__

`DoubleVector___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DoubleVector___nonzero__', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector___nonzero__`, 'returnType') = 'logical'
attr(`DoubleVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector___nonzero__`) = c("SWIGFunction", class('DoubleVector___nonzero__'))

# Start of DoubleVector___len__

`DoubleVector___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DoubleVector___len__', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector___len__`, 'returnType') = 'integer'
attr(`DoubleVector___len__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector___len__`) = c("SWIGFunction", class('DoubleVector___len__'))

# Start of DoubleVector_pop

`DoubleVector_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DoubleVector_pop', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector_pop`, 'returnType') = 'numeric'
attr(`DoubleVector_pop`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_pop`) = c("SWIGFunction", class('DoubleVector_pop'))

# Start of DoubleVector___getslice__

`DoubleVector___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_DoubleVector___getslice__', self, i, j, PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector___getslice__`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`DoubleVector___getslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer')
class(`DoubleVector___getslice__`) = c("SWIGFunction", class('DoubleVector___getslice__'))

# Start of DoubleVector___setslice__

`DoubleVector___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_DoubleVector___setslice__', self, i, j, v, PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector___setslice__`, 'returnType') = 'void'
attr(`DoubleVector___setslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector___setslice__`) = c("SWIGFunction", class('DoubleVector___setslice__'))

# Start of DoubleVector___delslice__

`DoubleVector___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_DoubleVector___delslice__', self, i, j, PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector___delslice__`, 'returnType') = 'void'
attr(`DoubleVector___delslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer')
class(`DoubleVector___delslice__`) = c("SWIGFunction", class('DoubleVector___delslice__'))

# Start of DoubleVector___delitem__

`DoubleVector___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_DoubleVector___delitem__', self, i, PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector___delitem__`, 'returnType') = 'void'
attr(`DoubleVector___delitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`DoubleVector___delitem__`) = c("SWIGFunction", class('DoubleVector___delitem__'))

# Start of DoubleVector___getitem__

`DoubleVector___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_DoubleVector___getitem__', self, i, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector___getitem__`, 'returnType') = 'numeric'
attr(`DoubleVector___getitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`DoubleVector___getitem__`) = c("SWIGFunction", class('DoubleVector___getitem__'))

# Start of DoubleVector___setitem__

`DoubleVector___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_DoubleVector___setitem__', self, i, x, PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector___setitem__`, 'returnType') = 'void'
attr(`DoubleVector___setitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`DoubleVector___setitem__`) = c("SWIGFunction", class('DoubleVector___setitem__'))

# Start of DoubleVector_append

`DoubleVector_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_DoubleVector_append', self, x, PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector_append`, 'returnType') = 'void'
attr(`DoubleVector_append`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`DoubleVector_append`) = c("SWIGFunction", class('DoubleVector_append'))

# Start of new_DoubleVector

`DoubleVector__SWIG_0` = function()
{
  ;.Call('R_swig_new_DoubleVector__SWIG_0', PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector__SWIG_0`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
class(`DoubleVector__SWIG_0`) = c("SWIGFunction", class('DoubleVector__SWIG_0'))

# Start of new_DoubleVector

`DoubleVector__SWIG_1` = function(s_arg1)
{
  ;.Call('R_swig_new_DoubleVector__SWIG_1', s_arg1, PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector__SWIG_1`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`DoubleVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector__SWIG_1`) = c("SWIGFunction", class('DoubleVector__SWIG_1'))

# Start of DoubleVector_empty

`DoubleVector_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DoubleVector_empty', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector_empty`, 'returnType') = 'logical'
attr(`DoubleVector_empty`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_empty`) = c("SWIGFunction", class('DoubleVector_empty'))

# Start of DoubleVector_size

`DoubleVector_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DoubleVector_size', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector_size`, 'returnType') = 'integer'
attr(`DoubleVector_size`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_size`) = c("SWIGFunction", class('DoubleVector_size'))

# Start of DoubleVector_clear

`DoubleVector_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DoubleVector_clear', self, PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector_clear`, 'returnType') = 'void'
attr(`DoubleVector_clear`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_clear`) = c("SWIGFunction", class('DoubleVector_clear'))

# Start of DoubleVector_swap

`DoubleVector_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_DoubleVector_swap', self, v, PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector_swap`, 'returnType') = 'void'
attr(`DoubleVector_swap`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_swap`) = c("SWIGFunction", class('DoubleVector_swap'))

# Start of DoubleVector_get_allocator

`DoubleVector_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_DoubleVector_get_allocator', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  ans <- new("_p_std__allocatorT_double_t", ref=ans);
  
  ans
  
}

attr(`DoubleVector_get_allocator`, 'returnType') = '_p_std__allocatorT_double_t'
attr(`DoubleVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_get_allocator`) = c("SWIGFunction", class('DoubleVector_get_allocator'))

# Start of new_DoubleVector

`DoubleVector__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_DoubleVector__SWIG_2', size, PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector__SWIG_2`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`DoubleVector__SWIG_2`, "inputTypes") = c('integer')
class(`DoubleVector__SWIG_2`) = c("SWIGFunction", class('DoubleVector__SWIG_2'))

# Start of DoubleVector_pop_back

`DoubleVector_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DoubleVector_pop_back', self, PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector_pop_back`, 'returnType') = 'void'
attr(`DoubleVector_pop_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_pop_back`) = c("SWIGFunction", class('DoubleVector_pop_back'))

# Start of DoubleVector_resize

`DoubleVector_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_DoubleVector_resize__SWIG_0', self, new_size, PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`DoubleVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`DoubleVector_resize__SWIG_0`) = c("SWIGFunction", class('DoubleVector_resize__SWIG_0'))

# Start of new_DoubleVector

`DoubleVector__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;.Call('R_swig_new_DoubleVector__SWIG_3', size, value, PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector__SWIG_3`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`DoubleVector__SWIG_3`, "inputTypes") = c('integer', 'numeric')
class(`DoubleVector__SWIG_3`) = c("SWIGFunction", class('DoubleVector__SWIG_3'))

`DoubleVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- DoubleVector__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- DoubleVector__SWIG_2; 
    }
    else if (( is.numeric(argv[[1]]) )) {
      f <- DoubleVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && is.numeric(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- DoubleVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for DoubleVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DoubleVector_push_back

`DoubleVector_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_DoubleVector_push_back', self, x, PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector_push_back`, 'returnType') = 'void'
attr(`DoubleVector_push_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`DoubleVector_push_back`) = c("SWIGFunction", class('DoubleVector_push_back'))

# Start of DoubleVector_front

`DoubleVector_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DoubleVector_front', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector_front`, 'returnType') = 'numeric'
attr(`DoubleVector_front`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_front`) = c("SWIGFunction", class('DoubleVector_front'))

# Start of DoubleVector_back

`DoubleVector_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DoubleVector_back', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector_back`, 'returnType') = 'numeric'
attr(`DoubleVector_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_back`) = c("SWIGFunction", class('DoubleVector_back'))

# Start of DoubleVector_assign

`DoubleVector_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_DoubleVector_assign', self, n, x, PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector_assign`, 'returnType') = 'void'
attr(`DoubleVector_assign`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`DoubleVector_assign`) = c("SWIGFunction", class('DoubleVector_assign'))

# Start of DoubleVector_resize

`DoubleVector_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_DoubleVector_resize__SWIG_1', self, new_size, x, PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`DoubleVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`DoubleVector_resize__SWIG_1`) = c("SWIGFunction", class('DoubleVector_resize__SWIG_1'))

`DoubleVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_double_std__allocatorT_double_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- DoubleVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_double_std__allocatorT_double_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.numeric(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- DoubleVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for DoubleVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DoubleVector_reserve

`DoubleVector_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_DoubleVector_reserve', self, n, PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector_reserve`, 'returnType') = 'void'
attr(`DoubleVector_reserve`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`DoubleVector_reserve`) = c("SWIGFunction", class('DoubleVector_reserve'))

# Start of DoubleVector_capacity

`DoubleVector_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DoubleVector_capacity', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`DoubleVector_capacity`, 'returnType') = 'integer'
attr(`DoubleVector_capacity`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_capacity`) = c("SWIGFunction", class('DoubleVector_capacity'))

# Start of delete_DoubleVector

`delete_DoubleVector` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_DoubleVector', self, PACKAGE='sequential_analysis_wrap');
  
}

attr(`delete_DoubleVector`, 'returnType') = 'void'
attr(`delete_DoubleVector`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`delete_DoubleVector`) = c("SWIGFunction", class('delete_DoubleVector'))

# Start of accessor method for std::vector<(double)>
setMethod('$', '_p_std__vectorT_double_std__allocatorT_double_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = DoubleVector___nonzero__, '__len__' = DoubleVector___len__, 'pop' = DoubleVector_pop, '__getslice__' = DoubleVector___getslice__, '__setslice__' = DoubleVector___setslice__, '__delslice__' = DoubleVector___delslice__, '__delitem__' = DoubleVector___delitem__, '__getitem__' = DoubleVector___getitem__, '__setitem__' = DoubleVector___setitem__, 'append' = DoubleVector_append, 'empty' = DoubleVector_empty, 'size' = DoubleVector_size, 'clear' = DoubleVector_clear, 'swap' = DoubleVector_swap, 'get_allocator' = DoubleVector_get_allocator, 'pop_back' = DoubleVector_pop_back, 'resize' = DoubleVector_resize, 'push_back' = DoubleVector_push_back, 'front' = DoubleVector_front, 'back' = DoubleVector_back, 'assign' = DoubleVector_assign, 'reserve' = DoubleVector_reserve, 'capacity' = DoubleVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(double)>
setMethod('delete', '_p_std__vectorT_double_std__allocatorT_double_t_t', function(obj) {delete_std__vectorT_double_std__allocatorT_double_t_t(obj)})
# Start of StringVector___nonzero__

`StringVector___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector___nonzero__', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`StringVector___nonzero__`, 'returnType') = 'logical'
attr(`StringVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector___nonzero__`) = c("SWIGFunction", class('StringVector___nonzero__'))

# Start of StringVector___len__

`StringVector___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector___len__', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`StringVector___len__`, 'returnType') = 'integer'
attr(`StringVector___len__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector___len__`) = c("SWIGFunction", class('StringVector___len__'))

# Start of StringVector_pop

`StringVector_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_pop', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`StringVector_pop`, 'returnType') = 'character'
attr(`StringVector_pop`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_pop`) = c("SWIGFunction", class('StringVector_pop'))

# Start of StringVector___getslice__

`StringVector___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_StringVector___getslice__', self, i, j, PACKAGE='sequential_analysis_wrap');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  ans
  
}

attr(`StringVector___getslice__`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`StringVector___getslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer')
class(`StringVector___getslice__`) = c("SWIGFunction", class('StringVector___getslice__'))

# Start of StringVector___setslice__

`StringVector___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_StringVector___setslice__', self, i, j, v, PACKAGE='sequential_analysis_wrap');
  
}

attr(`StringVector___setslice__`, 'returnType') = 'void'
attr(`StringVector___setslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector___setslice__`) = c("SWIGFunction", class('StringVector___setslice__'))

# Start of StringVector___delslice__

`StringVector___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_StringVector___delslice__', self, i, j, PACKAGE='sequential_analysis_wrap');
  
}

attr(`StringVector___delslice__`, 'returnType') = 'void'
attr(`StringVector___delslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer')
class(`StringVector___delslice__`) = c("SWIGFunction", class('StringVector___delslice__'))

# Start of StringVector___delitem__

`StringVector___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_StringVector___delitem__', self, i, PACKAGE='sequential_analysis_wrap');
  
}

attr(`StringVector___delitem__`, 'returnType') = 'void'
attr(`StringVector___delitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`StringVector___delitem__`) = c("SWIGFunction", class('StringVector___delitem__'))

# Start of StringVector___getitem__

`StringVector___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_StringVector___getitem__', self, i, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`StringVector___getitem__`, 'returnType') = 'character'
attr(`StringVector___getitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`StringVector___getitem__`) = c("SWIGFunction", class('StringVector___getitem__'))

# Start of StringVector___setitem__

`StringVector___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_StringVector___setitem__', self, i, x, PACKAGE='sequential_analysis_wrap');
  
}

attr(`StringVector___setitem__`, 'returnType') = 'void'
attr(`StringVector___setitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`StringVector___setitem__`) = c("SWIGFunction", class('StringVector___setitem__'))

# Start of StringVector_append

`StringVector_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as(x, "character"); 
  ;.Call('R_swig_StringVector_append', self, x, PACKAGE='sequential_analysis_wrap');
  
}

attr(`StringVector_append`, 'returnType') = 'void'
attr(`StringVector_append`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'character')
class(`StringVector_append`) = c("SWIGFunction", class('StringVector_append'))

# Start of new_StringVector

`StringVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_StringVector__SWIG_0', PACKAGE='sequential_analysis_wrap');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_StringVector)
  ans
  
}

attr(`StringVector__SWIG_0`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
class(`StringVector__SWIG_0`) = c("SWIGFunction", class('StringVector__SWIG_0'))

# Start of new_StringVector

`StringVector__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_new_StringVector__SWIG_1', s_arg1, PACKAGE='sequential_analysis_wrap');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_StringVector)
  ans
  
}

attr(`StringVector__SWIG_1`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`StringVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector__SWIG_1`) = c("SWIGFunction", class('StringVector__SWIG_1'))

# Start of StringVector_empty

`StringVector_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_empty', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`StringVector_empty`, 'returnType') = 'logical'
attr(`StringVector_empty`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_empty`) = c("SWIGFunction", class('StringVector_empty'))

# Start of StringVector_size

`StringVector_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_size', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`StringVector_size`, 'returnType') = 'integer'
attr(`StringVector_size`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_size`) = c("SWIGFunction", class('StringVector_size'))

# Start of StringVector_clear

`StringVector_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_clear', self, PACKAGE='sequential_analysis_wrap');
  
}

attr(`StringVector_clear`, 'returnType') = 'void'
attr(`StringVector_clear`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_clear`) = c("SWIGFunction", class('StringVector_clear'))

# Start of StringVector_swap

`StringVector_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_StringVector_swap', self, v, PACKAGE='sequential_analysis_wrap');
  
}

attr(`StringVector_swap`, 'returnType') = 'void'
attr(`StringVector_swap`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_swap`) = c("SWIGFunction", class('StringVector_swap'))

# Start of StringVector_get_allocator

`StringVector_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_StringVector_get_allocator', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  ans <- new("_p_std__allocatorT_std__string_t", ref=ans);
  
  ans
  
}

attr(`StringVector_get_allocator`, 'returnType') = '_p_std__allocatorT_std__string_t'
attr(`StringVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_get_allocator`) = c("SWIGFunction", class('StringVector_get_allocator'))

# Start of new_StringVector

`StringVector__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_StringVector__SWIG_2', size, PACKAGE='sequential_analysis_wrap');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_StringVector)
  ans
  
}

attr(`StringVector__SWIG_2`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`StringVector__SWIG_2`, "inputTypes") = c('integer')
class(`StringVector__SWIG_2`) = c("SWIGFunction", class('StringVector__SWIG_2'))

# Start of StringVector_pop_back

`StringVector_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_pop_back', self, PACKAGE='sequential_analysis_wrap');
  
}

attr(`StringVector_pop_back`, 'returnType') = 'void'
attr(`StringVector_pop_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_pop_back`) = c("SWIGFunction", class('StringVector_pop_back'))

# Start of StringVector_resize

`StringVector_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_StringVector_resize__SWIG_0', self, new_size, PACKAGE='sequential_analysis_wrap');
  
}

attr(`StringVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`StringVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`StringVector_resize__SWIG_0`) = c("SWIGFunction", class('StringVector_resize__SWIG_0'))

# Start of new_StringVector

`StringVector__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as(value, "character"); 
  ;ans = .Call('R_swig_new_StringVector__SWIG_3', size, value, PACKAGE='sequential_analysis_wrap');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_StringVector)
  ans
  
}

attr(`StringVector__SWIG_3`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`StringVector__SWIG_3`, "inputTypes") = c('integer', 'character')
class(`StringVector__SWIG_3`) = c("SWIGFunction", class('StringVector__SWIG_3'))

`StringVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- StringVector__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- StringVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && length(argv[[1]]) == 1) {
      f <- StringVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- StringVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for StringVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of StringVector_push_back

`StringVector_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as(x, "character"); 
  ;.Call('R_swig_StringVector_push_back', self, x, PACKAGE='sequential_analysis_wrap');
  
}

attr(`StringVector_push_back`, 'returnType') = 'void'
attr(`StringVector_push_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'character')
class(`StringVector_push_back`) = c("SWIGFunction", class('StringVector_push_back'))

# Start of StringVector_front

`StringVector_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_front', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`StringVector_front`, 'returnType') = 'character'
attr(`StringVector_front`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_front`) = c("SWIGFunction", class('StringVector_front'))

# Start of StringVector_back

`StringVector_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_back', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`StringVector_back`, 'returnType') = 'character'
attr(`StringVector_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_back`) = c("SWIGFunction", class('StringVector_back'))

# Start of StringVector_assign

`StringVector_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_StringVector_assign', self, n, x, PACKAGE='sequential_analysis_wrap');
  
}

attr(`StringVector_assign`, 'returnType') = 'void'
attr(`StringVector_assign`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`StringVector_assign`) = c("SWIGFunction", class('StringVector_assign'))

# Start of StringVector_resize

`StringVector_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_StringVector_resize__SWIG_1', self, new_size, x, PACKAGE='sequential_analysis_wrap');
  
}

attr(`StringVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`StringVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`StringVector_resize__SWIG_1`) = c("SWIGFunction", class('StringVector_resize__SWIG_1'))

`StringVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- StringVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- StringVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for StringVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of StringVector_reserve

`StringVector_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_StringVector_reserve', self, n, PACKAGE='sequential_analysis_wrap');
  
}

attr(`StringVector_reserve`, 'returnType') = 'void'
attr(`StringVector_reserve`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`StringVector_reserve`) = c("SWIGFunction", class('StringVector_reserve'))

# Start of StringVector_capacity

`StringVector_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_capacity', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`StringVector_capacity`, 'returnType') = 'integer'
attr(`StringVector_capacity`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_capacity`) = c("SWIGFunction", class('StringVector_capacity'))

# Start of delete_StringVector

`delete_StringVector` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_StringVector', self, PACKAGE='sequential_analysis_wrap');
  
}

attr(`delete_StringVector`, 'returnType') = 'void'
attr(`delete_StringVector`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`delete_StringVector`) = c("SWIGFunction", class('delete_StringVector'))

# Start of accessor method for std::vector<(std::string)>
setMethod('$', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = StringVector___nonzero__, '__len__' = StringVector___len__, 'pop' = StringVector_pop, '__getslice__' = StringVector___getslice__, '__setslice__' = StringVector___setslice__, '__delslice__' = StringVector___delslice__, '__delitem__' = StringVector___delitem__, '__getitem__' = StringVector___getitem__, '__setitem__' = StringVector___setitem__, 'append' = StringVector_append, 'empty' = StringVector_empty, 'size' = StringVector_size, 'clear' = StringVector_clear, 'swap' = StringVector_swap, 'get_allocator' = StringVector_get_allocator, 'pop_back' = StringVector_pop_back, 'resize' = StringVector_resize, 'push_back' = StringVector_push_back, 'front' = StringVector_front, 'back' = StringVector_back, 'assign' = StringVector_assign, 'reserve' = StringVector_reserve, 'capacity' = StringVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::string)>
setMethod('delete', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', function(obj) {delete_std__vectorT_std__string_std__allocatorT_std__string_t_t(obj)})
# Start of new_ConnectivityMatrix

`ConnectivityMatrix__SWIG_0` = function(origins, destinations)
{
  if (inherits(origins, "ExternalReference")) origins = slot(origins,"ref") 
  if (inherits(destinations, "ExternalReference")) destinations = slot(destinations,"ref") 
  ;ans = .Call('R_swig_new_ConnectivityMatrix__SWIG_0', origins, destinations, PACKAGE='sequential_analysis_wrap');
  ans <- new("_p_ConnectivityMatrix", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_ConnectivityMatrix)
  ans
  
}

attr(`ConnectivityMatrix__SWIG_0`, 'returnType') = '_p_ConnectivityMatrix'
attr(`ConnectivityMatrix__SWIG_0`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`ConnectivityMatrix__SWIG_0`) = c("SWIGFunction", class('ConnectivityMatrix__SWIG_0'))

# Start of new_ConnectivityMatrix

`ConnectivityMatrix__SWIG_1` = function(origins)
{
  if (inherits(origins, "ExternalReference")) origins = slot(origins,"ref") 
  ;ans = .Call('R_swig_new_ConnectivityMatrix__SWIG_1', origins, PACKAGE='sequential_analysis_wrap');
  ans <- new("_p_ConnectivityMatrix", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_ConnectivityMatrix)
  ans
  
}

attr(`ConnectivityMatrix__SWIG_1`, 'returnType') = '_p_ConnectivityMatrix'
attr(`ConnectivityMatrix__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`ConnectivityMatrix__SWIG_1`) = c("SWIGFunction", class('ConnectivityMatrix__SWIG_1'))

# Start of new_ConnectivityMatrix

`ConnectivityMatrix__SWIG_2` = function()
{
  ;ans = .Call('R_swig_new_ConnectivityMatrix__SWIG_2', PACKAGE='sequential_analysis_wrap');
  ans <- new("_p_ConnectivityMatrix", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_ConnectivityMatrix)
  ans
  
}

attr(`ConnectivityMatrix__SWIG_2`, 'returnType') = '_p_ConnectivityMatrix'
class(`ConnectivityMatrix__SWIG_2`) = c("SWIGFunction", class('ConnectivityMatrix__SWIG_2'))

`ConnectivityMatrix` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- ConnectivityMatrix__SWIG_2; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && length(argv[[1]]) == 1) {
      f <- ConnectivityMatrix__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && length(argv[[2]]) == 1) {
      f <- ConnectivityMatrix__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for ConnectivityMatrix with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of ConnectivityMatrix_allocate

`ConnectivityMatrix_allocate` = function(self, n, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;ans = .Call('R_swig_ConnectivityMatrix_allocate', self, n, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  return(ans)
  ans <- new("_p_std__vectorT_int_std__allocatorT_int_t_t", ref=ans);
  ans
  
}

attr(`ConnectivityMatrix_allocate`, 'returnType') = 'integer'
attr(`ConnectivityMatrix_allocate`, "inputTypes") = c('_p_ConnectivityMatrix', 'integer')
class(`ConnectivityMatrix_allocate`) = c("SWIGFunction", class('ConnectivityMatrix_allocate'))

# Start of ConnectivityMatrix_get_counts

`ConnectivityMatrix_get_counts` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ConnectivityMatrix_get_counts', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`ConnectivityMatrix_get_counts`, 'returnType') = 'list'
attr(`ConnectivityMatrix_get_counts`, "inputTypes") = c('_p_ConnectivityMatrix')
class(`ConnectivityMatrix_get_counts`) = c("SWIGFunction", class('ConnectivityMatrix_get_counts'))

# Start of ConnectivityMatrix_obj_fn_cv

`ConnectivityMatrix_obj_fn_cv` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ConnectivityMatrix_obj_fn_cv', self, as.logical(.copy), PACKAGE='sequential_analysis_wrap');
  
}

attr(`ConnectivityMatrix_obj_fn_cv`, 'returnType') = 'numeric'
attr(`ConnectivityMatrix_obj_fn_cv`, "inputTypes") = c('_p_ConnectivityMatrix')
class(`ConnectivityMatrix_obj_fn_cv`) = c("SWIGFunction", class('ConnectivityMatrix_obj_fn_cv'))

# Start of ConnectivityMatrix_set_obj_fn_cv_args

`ConnectivityMatrix_set_obj_fn_cv_args` = function(self, delta, pi)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  
  ;.Call('R_swig_ConnectivityMatrix_set_obj_fn_cv_args', self, delta, pi, PACKAGE='sequential_analysis_wrap');
  
}

attr(`ConnectivityMatrix_set_obj_fn_cv_args`, 'returnType') = 'void'
attr(`ConnectivityMatrix_set_obj_fn_cv_args`, "inputTypes") = c('_p_ConnectivityMatrix', 'numeric', 'numeric')
class(`ConnectivityMatrix_set_obj_fn_cv_args`) = c("SWIGFunction", class('ConnectivityMatrix_set_obj_fn_cv_args'))

# Start of ConnectivityMatrix_update

`ConnectivityMatrix_update` = function(self, counts)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  counts = lapply(counts, as.integer);
  ;.Call('R_swig_ConnectivityMatrix_update', self, counts, PACKAGE='sequential_analysis_wrap');
  
}

attr(`ConnectivityMatrix_update`, 'returnType') = 'void'
attr(`ConnectivityMatrix_update`, "inputTypes") = c('_p_ConnectivityMatrix', 'list')
class(`ConnectivityMatrix_update`) = c("SWIGFunction", class('ConnectivityMatrix_update'))

# Start of delete_ConnectivityMatrix

`delete_ConnectivityMatrix` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_ConnectivityMatrix', self, PACKAGE='sequential_analysis_wrap');
  
}

attr(`delete_ConnectivityMatrix`, 'returnType') = 'void'
attr(`delete_ConnectivityMatrix`, "inputTypes") = c('_p_ConnectivityMatrix')
class(`delete_ConnectivityMatrix`) = c("SWIGFunction", class('delete_ConnectivityMatrix'))

# Start of accessor method for ConnectivityMatrix
setMethod('$', '_p_ConnectivityMatrix', function(x, name)

{
  accessorFuns = list('allocate' = ConnectivityMatrix_allocate, 'get_counts' = ConnectivityMatrix_get_counts, 'obj_fn_cv' = ConnectivityMatrix_obj_fn_cv, 'set_obj_fn_cv_args' = ConnectivityMatrix_set_obj_fn_cv_args, 'update' = ConnectivityMatrix_update);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for ConnectivityMatrix
setMethod('delete', '_p_ConnectivityMatrix', function(obj) {delete_ConnectivityMatrix(obj)})

